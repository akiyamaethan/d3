// @deno-types="npm:@types/leaflet"
import leaflet from "leaflet";
import "leaflet/dist/leaflet.css";
import "./style.css";
import "./_leafletWorkaround.ts";
import luck from "./_luck.ts";

// ------------------- Basic UI Setup -------------------
const controlPanelDiv = document.createElement("div");
controlPanelDiv.id = "controlPanel";
document.body.append(controlPanelDiv);

const mapDiv = document.createElement("div");
mapDiv.id = "map";
document.body.append(mapDiv);

const statusPanelDiv = document.createElement("div");
statusPanelDiv.id = "statusPanel";
document.body.append(statusPanelDiv);

// ------------------- Game Parameters -------------------
const START_LAT = 36.997936938057016;
const START_LNG = -122.05703507501151;

const TILE_DEGREES = 1e-4;
const NEIGHBORHOOD_SIZE = 3;
const CACHE_SPAWN_PROBABILITY = 0.1;
const GAMEPLAY_ZOOM_LEVEL = 19;
const MIN_ZOOM_LEVEL = 17;
const MAX_ZOOM_LEVEL = 24;
const WIN_THRESHOLD = 64;

// ------------------- Map Setup -------------------
const map = leaflet.map(mapDiv, {
  center: [START_LAT, START_LNG],
  zoom: GAMEPLAY_ZOOM_LEVEL,
  minZoom: MIN_ZOOM_LEVEL,
  maxZoom: MAX_ZOOM_LEVEL,
  zoomControl: false,
  scrollWheelZoom: true,
  keyboard: false,
});

const _baseTile = leaflet
  .tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution:
      '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
  })
  .addTo(map);

// ------------------- Player -------------------
let playerLat = START_LAT;
let playerLng = START_LNG;

const playerMarker = leaflet.marker([playerLat, playerLng]).bindTooltip(
  "That's you!",
);
playerMarker.addTo(map);

statusPanelDiv.innerText = "No points yet...";

function updatePlayerMarker() {
  playerMarker.setLatLng([playerLat, playerLng]);
  map.setView([playerLat, playerLng]);
  renderGrid();
}

// ------------------- Inventory -------------------
type Token = { value: number; i: number; j: number };
let heldToken: Token | null = null;

const inventoryDiv = document.createElement("div");
inventoryDiv.id = "inventoryPanel";
inventoryDiv.style.marginTop = "10px";
inventoryDiv.style.fontWeight = "bold";
inventoryDiv.innerText = "Holding: None";
controlPanelDiv.appendChild(inventoryDiv);

function updateInventoryUI() {
  inventoryDiv.innerText = heldToken
    ? `Holding: ${heldToken.value}`
    : "Holding: None";
}

// ------------------- Persistence (Flyweight + Memento) -------------------
// We only store modified cells here. Unmodified cells are generated by luck() on demand.
type CellMemento = { tokenValue: number | null }; // null = empty
const modifiedCells = new Map<string, CellMemento>(); // Memento store (persistent when cell modified)

// Utility keys & conversions
function cellKey(i: number, j: number) {
  return `${i},${j}`;
}
function cellCenter(i: number, j: number): [number, number] {
  return [(i + 0.5) * TILE_DEGREES, (j + 0.5) * TILE_DEGREES];
}
function cellToBounds(i: number, j: number) {
  return leaflet.latLngBounds([i * TILE_DEGREES, j * TILE_DEGREES], [
    (i + 1) * TILE_DEGREES,
    (j + 1) * TILE_DEGREES,
  ]);
}
function latLngToCell(lat: number, lng: number) {
  return {
    i: Math.floor(lat / TILE_DEGREES),
    j: Math.floor(lng / TILE_DEGREES),
  };
}

// ------------------- Visual caches (transient) -------------------
// These maps store active Leaflet layers / markers for the current viewport only.
// They are cleared/removed when cells scroll off-screen.
const cellLayers = new Map<string, leaflet.Rectangle>();
const valueMarkers = new Map<string, leaflet.Marker>();

// ------------------- Cell state API -------------------
// Get cell token: first check modifiedCells (memento). If not found, deterministically generate via luck().
// IMPORTANT: calling this does NOT create a memento. Only writes happen (player collect/place/craft) create mementos.
function getCellTokenValue(i: number, j: number): number | null {
  const key = cellKey(i, j);
  if (modifiedCells.has(key)) {
    return modifiedCells.get(key)!.tokenValue; // may be null
  }
  // Deterministic spawn using global coordinates (flyweight generation)
  const spawnChance = luck(`${i},${j},spawn`);
  if (spawnChance < CACHE_SPAWN_PROBABILITY) {
    const value = 1 << Math.floor(luck(`${i},${j},value`) * 4); // 1,2,4,8
    return value;
  }
  return null;
}

// Persist a modification to a cell (memento). Setting tokenValue to null marks it empty.
function setCellTokenValue(i: number, j: number, tokenValue: number | null) {
  const key = cellKey(i, j);
  modifiedCells.set(key, { tokenValue });
}

// Remove a persisted modification (rarely used) - keeps flyweight behavior
function _forgetCell(i: number, j: number) {
  modifiedCells.delete(cellKey(i, j));
}

// ------------------- Victory UI -------------------
let hasWon = false;
const winOverlay = document.createElement("div");
winOverlay.id = "winOverlay";
winOverlay.style.position = "fixed";
winOverlay.style.top = "0";
winOverlay.style.left = "0";
winOverlay.style.width = "100%";
winOverlay.style.height = "100%";
winOverlay.style.display = "none";
winOverlay.style.backgroundColor = "rgba(0,0,0,0.8)";
winOverlay.style.color = "white";
winOverlay.style.fontSize = "48px";
winOverlay.style.fontWeight = "bold";
winOverlay.style.justifyContent = "center";
winOverlay.style.alignItems = "center";
winOverlay.style.flexDirection = "column";
winOverlay.style.zIndex = "9999";
winOverlay.style.textAlign = "center";

const winText = document.createElement("div");
winText.innerText = "üéâ You Win! üéâ";
winOverlay.appendChild(winText);

const resetButton = document.createElement("button");
resetButton.innerText = "Play Again";
resetButton.style.marginTop = "20px";
resetButton.style.fontSize = "24px";
resetButton.addEventListener("click", resetGame);
winOverlay.appendChild(resetButton);

document.body.appendChild(winOverlay);

function declareVictory() {
  hasWon = true;
  winOverlay.style.display = "flex";
}

// ------------------- Interaction (contextual click, no modal) -------------------
// Perform the contextual action for a cell (automatically pick up / craft / place)
function handleCellClick(i: number, j: number) {
  if (hasWon) return;
  const key = cellKey(i, j);
  // Only allow interactions within NEIGHBORHOOD_SIZE
  const playerCell = latLngToCell(playerLat, playerLng);
  const distance = Math.max(
    Math.abs(i - playerCell.i),
    Math.abs(j - playerCell.j),
  );
  if (distance > NEIGHBORHOOD_SIZE) return; // too far

  // Determine current token value (either persisted or generated)
  const currentValue = getCellTokenValue(i, j);

  // CASE 1: cell has token, inventory empty -> pick up token (and if it came from generated cell, write memento null to represent collected)
  if (currentValue !== null && heldToken === null) {
    // pick up
    heldToken = { value: currentValue, i, j };
    updateInventoryUI();
    // persist that cell is now empty (memento) so it stays empty when leaving/returning
    setCellTokenValue(i, j, null);
    // remove visual marker if present
    if (valueMarkers.has(key)) {
      map.removeLayer(valueMarkers.get(key)!);
      valueMarkers.delete(key);
    }
    renderGrid();
    return;
  }

  // CASE 2: cell has token, inventory full -> if same value craft; else do nothing
  if (currentValue !== null && heldToken !== null) {
    if (currentValue === heldToken.value) {
      // craft: produce doubled token in the cell and clear inventory
      const newValue = currentValue * 2;
      setCellTokenValue(i, j, newValue); // persist modified token
      heldToken = null;
      updateInventoryUI();
      // update visual marker
      if (valueMarkers.has(key)) {
        map.removeLayer(valueMarkers.get(key)!);
        valueMarkers.delete(key);
      }
      const marker = leaflet.marker(cellCenter(i, j), {
        icon: leaflet.divIcon({
          className: "token-value",
          html: `<div style="font-weight:bold;color:black;">${newValue}</div>`,
          iconSize: [TILE_DEGREES * 100000, TILE_DEGREES * 100000],
        }),
        interactive: false,
      }).addTo(map);
      valueMarkers.set(key, marker);
      renderGrid();
      if (newValue >= WIN_THRESHOLD) declareVictory();
    }
    return;
  }

  // CASE 3: cell empty, inventory full -> place token
  if (currentValue === null && heldToken !== null) {
    setCellTokenValue(i, j, heldToken.value);
    heldToken = null;
    updateInventoryUI();
    // add marker
    if (valueMarkers.has(key)) {
      map.removeLayer(valueMarkers.get(key)!);
      valueMarkers.delete(key);
    }
    const marker = leaflet.marker(cellCenter(i, j), {
      icon: leaflet.divIcon({
        className: "token-value",
        html: `<div style="font-weight:bold;color:black;">${
          modifiedCells.get(key)!.tokenValue
        }</div>`,
        iconSize: [TILE_DEGREES * 100000, TILE_DEGREES * 100000],
      }),
      interactive: false,
    }).addTo(map);
    valueMarkers.set(key, marker);
    renderGrid();
    return;
  }

  // CASE 4: empty cell & empty inventory -> nothing
  return;
}

// ------------------- Render Grid -------------------
// IMPORTANT: we rebuild visible layers each render using modifiedCells + deterministic flyweight generation.
// Off-screen layers and markers are removed and modifiedCells entries persist (mementos).
function renderGrid() {
  if (hasWon) return;

  const playerCell = latLngToCell(playerLat, playerLng);

  const bounds = map.getBounds();
  const minI = Math.floor(bounds.getSouth() / TILE_DEGREES);
  const maxI = Math.ceil(bounds.getNorth() / TILE_DEGREES);
  const minJ = Math.floor(bounds.getWest() / TILE_DEGREES);
  const maxJ = Math.ceil(bounds.getEast() / TILE_DEGREES);

  // Remove off-screen layers & markers (keep modifiedCells mementos intact)
  for (const [k, layer] of cellLayers.entries()) {
    const [i, j] = k.split(",").map(Number);
    if (i < minI || i > maxI || j < minJ || j > maxJ) {
      map.removeLayer(layer);
      cellLayers.delete(k);
      if (valueMarkers.has(k)) {
        map.removeLayer(valueMarkers.get(k)!);
        valueMarkers.delete(k);
      }
    }
  }

  // Build visible grid from scratch using either modifiedCells (mementos) or luck()
  for (let i = minI; i <= maxI; i++) {
    for (let j = minJ; j <= maxJ; j++) {
      const k = cellKey(i, j);
      const distance = Math.max(
        Math.abs(i - playerCell.i),
        Math.abs(j - playerCell.j),
      );
      const color = distance <= NEIGHBORHOOD_SIZE ? "yellow" : "#3388ff";

      // Create or update rectangle
      let rect: leaflet.Rectangle;
      if (!cellLayers.has(k)) {
        rect = leaflet.rectangle(cellToBounds(i, j), { color, weight: 1 })
          .addTo(map);
        cellLayers.set(k, rect);
        // attach click handler to rectangle for direct interactions
        rect.on("click", () => handleCellClick(i, j));
      } else {
        rect = cellLayers.get(k)!;
        rect.setStyle({ color });
      }

      // Token display: use persisted memento if present; otherwise deterministic generation
      const tokenValue = getCellTokenValue(i, j);
      if (tokenValue !== null && distance <= NEIGHBORHOOD_SIZE) {
        // ensure there's a visible marker
        if (!valueMarkers.has(k)) {
          const marker = leaflet.marker(cellCenter(i, j), {
            icon: leaflet.divIcon({
              className: "token-value",
              html:
                `<div style="font-weight:bold;color:black;">${tokenValue}</div>`,
              iconSize: [TILE_DEGREES * 100000, TILE_DEGREES * 100000],
            }),
            interactive: false,
          }).addTo(map);
          valueMarkers.set(k, marker);
        } else {
          // update marker html if memento changed
          const m = valueMarkers.get(k)!;
          const div = m.getElement()?.querySelector("div") as
            | HTMLElement
            | null;
          if (div) div.innerText = `${tokenValue}`;
        }
      } else {
        // if token not in range or not present, remove any existing marker
        if (valueMarkers.has(k)) {
          map.removeLayer(valueMarkers.get(k)!);
          valueMarkers.delete(k);
        }
      }
    }
  }
}

// ------------------- Movement Controls -------------------
const moveDiv = document.createElement("div");
moveDiv.innerHTML = `
  <button id="north">‚Üë</button><br/>
  <button id="west">‚Üê</button>
  <button id="south">‚Üì</button>
  <button id="east">‚Üí</button>
`;
controlPanelDiv.appendChild(moveDiv);

function movePlayer(di: number, dj: number) {
  if (hasWon) return;
  playerLat += di * TILE_DEGREES;
  playerLng += dj * TILE_DEGREES;
  updatePlayerMarker();
}

document.getElementById("north")!.addEventListener(
  "click",
  () => movePlayer(1, 0),
);
document.getElementById("south")!.addEventListener(
  "click",
  () => movePlayer(-1, 0),
);
document.getElementById("west")!.addEventListener(
  "click",
  () => movePlayer(0, -1),
);
document.getElementById("east")!.addEventListener(
  "click",
  () => movePlayer(0, 1),
);

globalThis.addEventListener("keydown", (e: KeyboardEvent) => {
  switch (e.key.toLowerCase()) {
    case "w":
    case "arrowup":
      movePlayer(1, 0);
      break;
    case "s":
    case "arrowdown":
      movePlayer(-1, 0);
      break;
    case "a":
    case "arrowleft":
      movePlayer(0, -1);
      break;
    case "d":
    case "arrowright":
      movePlayer(0, 1);
      break;
  }
});

// ------------------- Reset / Initialization -------------------
function resetGame() {
  hasWon = false;
  winOverlay.style.display = "none";
  heldToken = null;
  updateInventoryUI();

  // clear visual layers and markers
  for (const [_k, layer] of cellLayers.entries()) {
    map.removeLayer(layer);
  }
  cellLayers.clear();
  for (const [_k, m] of valueMarkers.entries()) {
    map.removeLayer(m);
  }
  valueMarkers.clear();

  // keep modifiedCells mementos cleared for a true restart
  modifiedCells.clear();

  // remove everything except base tile layer
  map.eachLayer((layer) => {
    if (layer instanceof leaflet.TileLayer) return; // keep base map
    map.removeLayer(layer);
  });

  playerLat = START_LAT;
  playerLng = START_LNG;
  playerMarker.addTo(map);
  renderGrid();
}

// start clean
resetGame();
map.on("moveend", renderGrid);
