// deno-lint-ignore-file
// @deno-types="npm:@types/leaflet"
import leaflet from "leaflet";
import "leaflet/dist/leaflet.css";
import "./style.css";
import "./_leafletWorkaround.ts";
import luck from "./_luck.ts";

// ------------------- Basic UI Setup -------------------
const controlPanelDiv = document.createElement("div");
controlPanelDiv.id = "controlPanel";
document.body.append(controlPanelDiv);

const mapDiv = document.createElement("div");
mapDiv.id = "map";
document.body.append(mapDiv);

const statusPanelDiv = document.createElement("div");
statusPanelDiv.id = "statusPanel";
document.body.append(statusPanelDiv);

// ------------------- Game Parameters -------------------
const START_LAT = 36.997936938057016;
const START_LNG = -122.05703507501151;

const TILE_DEGREES = 1e-4;
const NEIGHBORHOOD_SIZE = 3;
const CACHE_SPAWN_PROBABILITY = 0.1;
const GAMEPLAY_ZOOM_LEVEL = 19;
const MIN_ZOOM_LEVEL = 17;
const MAX_ZOOM_LEVEL = 24;
const WIN_THRESHOLD = 64;

// ------------------- Persistence Key -------------------
const STORAGE_KEY = "2048go_state_v1";

// ------------------- Map Setup -------------------
const map = leaflet.map(mapDiv, {
  center: [START_LAT, START_LNG],
  zoom: GAMEPLAY_ZOOM_LEVEL,
  minZoom: MIN_ZOOM_LEVEL,
  maxZoom: MAX_ZOOM_LEVEL,
  zoomControl: false,
  scrollWheelZoom: true,
  keyboard: false,
});

const baseTile = leaflet
  .tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution:
      '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
  })
  .addTo(map);

// ------------------- Player -------------------
let playerLat = START_LAT;
let playerLng = START_LNG;

const playerMarker = leaflet.marker([playerLat, playerLng]).bindTooltip(
  "That's you!",
);
playerMarker.addTo(map);

statusPanelDiv.innerText = "No points yet...";

function updatePlayerMarker() {
  playerMarker.setLatLng([playerLat, playerLng]);
  map.setView([playerLat, playerLng]);
  renderGrid();
  saveState(); // persist player movement
}

// ------------------- Inventory -------------------
type Token = { value: number; i: number; j: number };
let heldToken: Token | null = null;

const inventoryDiv = document.createElement("div");
inventoryDiv.id = "inventoryPanel";
inventoryDiv.style.marginTop = "10px";
inventoryDiv.style.fontWeight = "bold";
inventoryDiv.innerText = "Holding: None";
controlPanelDiv.appendChild(inventoryDiv);

function updateInventoryUI() {
  inventoryDiv.innerText = heldToken
    ? `Holding: ${heldToken.value}`
    : "Holding: None";
  saveState(); // persist inventory changes
}

// ------------------- Persistence (Flyweight + Memento) -------------------
// Only store modified cells here. Unmodified cells are generated by luck() on demand.
type CellMemento = { tokenValue: number | null }; // null = empty
const modifiedCells = new Map<string, CellMemento>(); // memento store

function cellKey(i: number, j: number) {
  return `${i},${j}`;
}
function cellCenter(i: number, j: number): [number, number] {
  return [(i + 0.5) * TILE_DEGREES, (j + 0.5) * TILE_DEGREES];
}
function cellToBounds(i: number, j: number) {
  return leaflet.latLngBounds([i * TILE_DEGREES, j * TILE_DEGREES], [
    (i + 1) * TILE_DEGREES,
    (j + 1) * TILE_DEGREES,
  ]);
}
function latLngToCell(lat: number, lng: number) {
  return {
    i: Math.floor(lat / TILE_DEGREES),
    j: Math.floor(lng / TILE_DEGREES),
  };
}

// ------------------- Visual caches (transient) -------------------
const cellLayers = new Map<string, leaflet.Rectangle>();
const valueMarkers = new Map<string, leaflet.Marker>();

// ------------------- Cell state API -------------------
function getCellTokenValue(i: number, j: number): number | null {
  const key = cellKey(i, j);
  if (modifiedCells.has(key)) return modifiedCells.get(key)!.tokenValue;
  const spawnChance = luck(`${i},${j},spawn`);
  if (spawnChance < CACHE_SPAWN_PROBABILITY) {
    return 1 << Math.floor(luck(`${i},${j},value`) * 4);
  }
  return null;
}

function setCellTokenValue(i: number, j: number, tokenValue: number | null) {
  const key = cellKey(i, j);
  // write-through memento
  modifiedCells.set(key, { tokenValue });
  saveState(); // persist modifications
}

// ------------------- Victory UI -------------------
let hasWon = false;
const winOverlay = document.createElement("div");
winOverlay.id = "winOverlay";
winOverlay.style.position = "fixed";
winOverlay.style.top = "0";
winOverlay.style.left = "0";
winOverlay.style.width = "100%";
winOverlay.style.height = "100%";
winOverlay.style.display = "none";
winOverlay.style.backgroundColor = "rgba(0,0,0,0.8)";
winOverlay.style.color = "white";
winOverlay.style.fontSize = "48px";
winOverlay.style.fontWeight = "bold";
winOverlay.style.justifyContent = "center";
winOverlay.style.alignItems = "center";
winOverlay.style.flexDirection = "column";
winOverlay.style.zIndex = "9999";
winOverlay.style.textAlign = "center";

const winText = document.createElement("div");
winText.innerText = "üéâ You Win! üéâ";
winOverlay.appendChild(winText);

const resetButton = document.createElement("button");
resetButton.innerText = "Play Again";
resetButton.style.marginTop = "20px";
resetButton.style.fontSize = "24px";
resetButton.addEventListener("click", () => {
  // Play Again invoked from overlay ‚Äî call resetGame which clears persisted state
  resetGame();
});
winOverlay.appendChild(resetButton);

document.body.appendChild(winOverlay);

function declareVictory() {
  hasWon = true;
  winOverlay.style.display = "flex";
  saveState();
}

// ------------------- Save / Load State (localStorage) -------------------
function saveState() {
  try {
    const obj: any = {
      playerLat,
      playerLng,
      hasWon,
      heldToken: heldToken
        ? { value: heldToken.value, i: heldToken.i, j: heldToken.j }
        : null,
      modifiedCells: Array.from(modifiedCells.entries()), // [[key,{tokenValue}],...]
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(obj));
  } catch (e) {
    console.error("Failed to save state:", e);
  }
}

function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return false;
    const obj = JSON.parse(raw);
    if (typeof obj !== "object" || obj == null) return false;

    // Restore player
    if (typeof obj.playerLat === "number") playerLat = obj.playerLat;
    if (typeof obj.playerLng === "number") playerLng = obj.playerLng;

    // Restore hasWon
    hasWon = !!obj.hasWon;
    if (hasWon) {
      winOverlay.style.display = "flex";
    } else {
      winOverlay.style.display = "none";
    }

    // Restore heldToken
    if (obj.heldToken && typeof obj.heldToken.value === "number") {
      heldToken = {
        value: obj.heldToken.value,
        i: obj.heldToken.i,
        j: obj.heldToken.j,
      };
    } else {
      heldToken = null;
    }
    updateInventoryUI();

    // Restore modifiedCells
    modifiedCells.clear();
    if (Array.isArray(obj.modifiedCells)) {
      for (const [k, val] of obj.modifiedCells) {
        // val should be an object with tokenValue (number|null)
        if (typeof k === "string" && val && ("tokenValue" in val)) {
          modifiedCells.set(k, { tokenValue: val.tokenValue });
        }
      }
    }

    return true;
  } catch (e) {
    console.error("Failed to load state:", e);
    return false;
  }
}

// ------------------- Interaction (contextual click, no modal) -------------------
function handleCellClick(i: number, j: number) {
  if (hasWon) return;
  const key = cellKey(i, j);
  const playerCell = latLngToCell(playerLat, playerLng);
  const distance = Math.max(
    Math.abs(i - playerCell.i),
    Math.abs(j - playerCell.j),
  );
  if (distance > NEIGHBORHOOD_SIZE) return;

  const currentValue = getCellTokenValue(i, j);

  // pick up
  if (currentValue !== null && heldToken === null) {
    heldToken = { value: currentValue, i, j };
    updateInventoryUI();
    setCellTokenValue(i, j, null); // persist that it's collected
    if (valueMarkers.has(key)) {
      map.removeLayer(valueMarkers.get(key)!);
      valueMarkers.delete(key);
    }
    renderGrid();
    return;
  }

  // craft
  if (currentValue !== null && heldToken !== null) {
    if (currentValue === heldToken.value) {
      const newValue = currentValue * 2;
      setCellTokenValue(i, j, newValue); // persist new token
      heldToken = null;
      updateInventoryUI();
      if (valueMarkers.has(key)) {
        map.removeLayer(valueMarkers.get(key)!);
        valueMarkers.delete(key);
      }
      const marker = leaflet.marker(cellCenter(i, j), {
        icon: leaflet.divIcon({
          className: "token-value",
          html: `<div style="font-weight:bold;color:black;">${newValue}</div>`,
          iconSize: [TILE_DEGREES * 100000, TILE_DEGREES * 100000],
        }),
        interactive: false,
      }).addTo(map);
      valueMarkers.set(key, marker);
      renderGrid();
      if (newValue >= WIN_THRESHOLD) declareVictory();
    }
    return;
  }

  // place
  if (currentValue === null && heldToken !== null) {
    setCellTokenValue(i, j, heldToken.value);
    heldToken = null;
    updateInventoryUI();
    if (valueMarkers.has(key)) {
      map.removeLayer(valueMarkers.get(key)!);
      valueMarkers.delete(key);
    }
    const marker = leaflet.marker(cellCenter(i, j), {
      icon: leaflet.divIcon({
        className: "token-value",
        html: `<div style="font-weight:bold;color:black;">${
          modifiedCells.get(key)!.tokenValue
        }</div>`,
        iconSize: [TILE_DEGREES * 100000, TILE_DEGREES * 100000],
      }),
      interactive: false,
    }).addTo(map);
    valueMarkers.set(key, marker);
    renderGrid();
    return;
  }

  return;
}

// ------------------- Render Grid -------------------
function renderGrid() {
  if (hasWon) return;
  const playerCell = latLngToCell(playerLat, playerLng);

  const bounds = map.getBounds();
  const minI = Math.floor(bounds.getSouth() / TILE_DEGREES);
  const maxI = Math.ceil(bounds.getNorth() / TILE_DEGREES);
  const minJ = Math.floor(bounds.getWest() / TILE_DEGREES);
  const maxJ = Math.ceil(bounds.getEast() / TILE_DEGREES);

  // Remove off-screen visual layers
  for (const [k, layer] of cellLayers.entries()) {
    const [i, j] = k.split(",").map(Number);
    if (i < minI || i > maxI || j < minJ || j > maxJ) {
      map.removeLayer(layer);
      cellLayers.delete(k);
      if (valueMarkers.has(k)) {
        map.removeLayer(valueMarkers.get(k)!);
        valueMarkers.delete(k);
      }
    }
  }

  // Build visible grid from scratch using modifiedCells (mementos) or luck()
  for (let i = minI; i <= maxI; i++) {
    for (let j = minJ; j <= maxJ; j++) {
      const k = cellKey(i, j);
      const distance = Math.max(
        Math.abs(i - playerCell.i),
        Math.abs(j - playerCell.j),
      );
      const color = distance <= NEIGHBORHOOD_SIZE ? "yellow" : "#3388ff";

      // Rectangle layer
      let rect: leaflet.Rectangle;
      if (!cellLayers.has(k)) {
        rect = leaflet.rectangle(cellToBounds(i, j), { color, weight: 1 })
          .addTo(map);
        cellLayers.set(k, rect);
        rect.on("click", () => handleCellClick(i, j));
      } else {
        rect = cellLayers.get(k)!;
        rect.setStyle({ color });
      }

      // Token marker (visible only near player)
      const tokenValue = getCellTokenValue(i, j);
      if (tokenValue !== null && distance <= NEIGHBORHOOD_SIZE) {
        if (!valueMarkers.has(k)) {
          const marker = leaflet.marker(cellCenter(i, j), {
            icon: leaflet.divIcon({
              className: "token-value",
              html:
                `<div style="font-weight:bold;color:black;">${tokenValue}</div>`,
              iconSize: [TILE_DEGREES * 100000, TILE_DEGREES * 100000],
            }),
            interactive: false,
          }).addTo(map);
          valueMarkers.set(k, marker);
        } else {
          const m = valueMarkers.get(k)!;
          const div = m.getElement()?.querySelector("div") as
            | HTMLElement
            | null;
          if (div) div.innerText = `${tokenValue}`;
        }
      } else {
        if (valueMarkers.has(k)) {
          map.removeLayer(valueMarkers.get(k)!);
          valueMarkers.delete(k);
        }
      }
    }
  }
}

// ------------------- Movement Controller -------------------
class MovementController {
  geolocation = false;
  watchId: number | null = null;

  enableGeolocation() {
    if (!navigator.geolocation) return;
    this.geolocation = true;
    if (this.watchId !== null) navigator.geolocation.clearWatch(this.watchId);
    this.watchId = navigator.geolocation.watchPosition(
      (pos) => {
        playerLat = pos.coords.latitude;
        playerLng = pos.coords.longitude;
        updatePlayerMarker(); // triggers render + save
      },
      console.error,
      { enableHighAccuracy: true, maximumAge: 1000 },
    );
  }

  disableGeolocation() {
    this.geolocation = false;
    if (this.watchId !== null) navigator.geolocation.clearWatch(this.watchId);
    this.watchId = null;
  }

  move(di: number, dj: number) {
    if (!this.geolocation) {
      playerLat += di * TILE_DEGREES;
      playerLng += dj * TILE_DEGREES;
      updatePlayerMarker(); // triggers render + save
    }
  }
}

const movementController = new MovementController();

// ------------------- Controls (buttons + keyboard) -------------------
const moveDiv = document.createElement("div");
moveDiv.innerHTML = `
  <button id="north">‚Üë</button><br/>
  <button id="west">‚Üê</button>
  <button id="south">‚Üì</button>
  <button id="east">‚Üí</button>
`;
controlPanelDiv.appendChild(moveDiv);

document.getElementById("north")!.addEventListener(
  "click",
  () => movementController.move(1, 0),
);
document.getElementById("south")!.addEventListener(
  "click",
  () => movementController.move(-1, 0),
);
document.getElementById("west")!.addEventListener(
  "click",
  () => movementController.move(0, -1),
);
document.getElementById("east")!.addEventListener(
  "click",
  () => movementController.move(0, 1),
);

globalThis.addEventListener("keydown", (e: KeyboardEvent) => {
  switch (e.key.toLowerCase()) {
    case "w":
    case "arrowup":
      movementController.move(1, 0);
      break;
    case "s":
    case "arrowdown":
      movementController.move(-1, 0);
      break;
    case "a":
    case "arrowleft":
      movementController.move(0, -1);
      break;
    case "d":
    case "arrowright":
      movementController.move(0, 1);
      break;
  }
});

// ------------------- Runtime Movement Mode Toggle -------------------
const modeToggle = document.createElement("button");
modeToggle.innerText = "Switch to Geolocation";
modeToggle.style.marginTop = "10px";
controlPanelDiv.appendChild(modeToggle);

modeToggle.addEventListener("click", () => {
  if (!movementController.geolocation) {
    movementController.enableGeolocation();
    modeToggle.innerText = "Switch to Keyboard/Buttons";
  } else {
    movementController.disableGeolocation();
    modeToggle.innerText = "Switch to Geolocation";
  }
});

// ------------------- New Game UI (Phase 3) -------------------
const newGameBtn = document.createElement("button");
newGameBtn.innerText = "New Game";
newGameBtn.style.marginLeft = "10px";
newGameBtn.addEventListener("click", () => {
  // Confirm with player before wiping persistent state
  const ok = confirm("Start a new game? This will erase saved progress.");
  if (ok) resetGame();
});
controlPanelDiv.appendChild(newGameBtn);

// ------------------- Reset / Initialization -------------------
function resetGame() {
  hasWon = false;
  winOverlay.style.display = "none";
  heldToken = null;
  updateInventoryUI();

  // Clear persisted state and transient visuals
  modifiedCells.clear();
  cellLayers.clear();
  valueMarkers.clear();
  try {
    localStorage.removeItem(STORAGE_KEY); // remove saved state -> true New Game
  } catch (e) {
    console.error("Failed to clear saved state:", e);
  }

  map.eachLayer((layer) => {
    if (layer === baseTile) return;
    map.removeLayer(layer);
  });

  playerLat = START_LAT;
  playerLng = START_LNG;
  playerMarker.addTo(map);
  updatePlayerMarker();
  saveState(); // save initial state (fresh)
}

// ------------------- Initial Load -------------------
map.whenReady(() => {
  const restored = loadState();
  if (restored) {
    // if we loaded state, ensure marker and grid reflect it
    playerMarker.addTo(map);
    updatePlayerMarker();
  } else {
    resetGame(); // fresh start
  }
});

map.on("moveend", renderGrid);
